{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GDBleed GDBleed - Dynamic-Static binary instrumentation framework on top of GDB GDBleed is a gdb wrapper exposing a set of commands for x86-64, ARM and MIPS (x86 and ARM thumb-mode in progress) architectures to perform binary instrumentation. The objective was to exploit the hackish features of GDB python API, while ignoring the software performance attribute (for now). And in the end to have a user-friendly framework. GDBleed focus is applicability, then we have efficiency. The more CPU archs it does suport the better it is. Why? \"easy\"-fast minimal static-dynamic code instrumentation supporting all main CPU archs Framework based on tools with a strong community support: GDB, gcc, r2, keystone, LIEF, etc. No control flow information is needed ideal for IoT devices, why? no binary instrumentation for MIPS cross-compilation is boring (and if it works then it will break somewhere during the execution) A lot of the new IoT devices still using old linux kernel versions not supporting EBPF Usage run gdb from the current folder Start the process using start command or attach gdb to the debugged process Run the command source gdbleed.py For more info take a look at the tests folder Req Tested on ubuntu 20.04 Dep: keystone, LIEF Installation Install # GEF gdb extension, ref https://github.com/hugsy/gef sudo apt-get -y install unzip cmake binutils Declare env vars # python's version which your gdb intalled supports export PYTHON_VER=\"python3\" sudo apt-get install ${PYTHON_VER}-distutils ${PYTHON_VER}-setuptools # don't change these values export KEYSTONE_VER=\"0.9.2\" export LIEF_VER=\"0.12.1\" From current folder run: ./setup.sh Required for hooking/instrumentation also aka Inline GOT hooking Install export TARGET=arm-linux-gnueabi sudo apt-get install -y binutils-${TARGET} gcc-${TARGET} export TARGET=mips-linux-gnu sudo apt-get install -y binutils-${TARGET} gcc-${TARGET} add vim highlighting augroup filetypedetect au! BufRead,BufNewFile *.c.bleed setfiletype c augroup END","title":"Home"},{"location":"#gdbleed","text":"GDBleed - Dynamic-Static binary instrumentation framework on top of GDB GDBleed is a gdb wrapper exposing a set of commands for x86-64, ARM and MIPS (x86 and ARM thumb-mode in progress) architectures to perform binary instrumentation. The objective was to exploit the hackish features of GDB python API, while ignoring the software performance attribute (for now). And in the end to have a user-friendly framework. GDBleed focus is applicability, then we have efficiency. The more CPU archs it does suport the better it is.","title":"GDBleed"},{"location":"#why","text":"\"easy\"-fast minimal static-dynamic code instrumentation supporting all main CPU archs Framework based on tools with a strong community support: GDB, gcc, r2, keystone, LIEF, etc. No control flow information is needed ideal for IoT devices, why? no binary instrumentation for MIPS cross-compilation is boring (and if it works then it will break somewhere during the execution) A lot of the new IoT devices still using old linux kernel versions not supporting EBPF","title":"Why?"},{"location":"#usage","text":"run gdb from the current folder Start the process using start command or attach gdb to the debugged process Run the command source gdbleed.py For more info take a look at the tests folder","title":"Usage"},{"location":"#req","text":"Tested on ubuntu 20.04 Dep: keystone, LIEF","title":"Req"},{"location":"#installation","text":"Install # GEF gdb extension, ref https://github.com/hugsy/gef sudo apt-get -y install unzip cmake binutils Declare env vars # python's version which your gdb intalled supports export PYTHON_VER=\"python3\" sudo apt-get install ${PYTHON_VER}-distutils ${PYTHON_VER}-setuptools # don't change these values export KEYSTONE_VER=\"0.9.2\" export LIEF_VER=\"0.12.1\" From current folder run: ./setup.sh Required for hooking/instrumentation also aka Inline GOT hooking Install export TARGET=arm-linux-gnueabi sudo apt-get install -y binutils-${TARGET} gcc-${TARGET} export TARGET=mips-linux-gnu sudo apt-get install -y binutils-${TARGET} gcc-${TARGET} add vim highlighting augroup filetypedetect au! BufRead,BufNewFile *.c.bleed setfiletype c augroup END","title":"Installation"},{"location":"start/","text":"start guide video Delete old gdbleed session which is saved into folder /tmp/gdbleed rm -rf /tmp/gdbleed Attach gdb to gdbserver session # e.g. we have /bin/bash with pid 258475, then we launch gdbserver as follows gdbserver --attach 127.0.0.1:12345 258475 # on gdb session cd <gdbleed-folder> gdb /bin/bash -ex \"source ~/.gdbinit-gef.py\" -ex \"target remote 127.0.0.1:12345\" -ex \"source gdbleed.py\" Because gdbleed does not know if the debuggee program is running in local or in remote it will ask you to choose on which path the binary is present. In any case if we are using gdbserver the 2nd options should be choosed. This information is later saved in gdbleed session (folder /tmp/gdbleed ) Inspect got entries gef\u27a4 got-entries ... [0x563275d6ced8] ---> socket [0x563275d6cee0] ---> mktemp gef\u27a4 got-entries fork [0x563275d6ce90] ---> fork Create static variables gef\u27a4 hook-got-inline --help Help Usage: hook-got-inline [options] <function_name> Options: --help : This message --create : insert gdbleed script from STDIN or by file <file_path> --data : Define or list global/static vars --list : print declared functions nformation --source-code : print function's source code --remove : delete function <function_name> --compile : Compile function --inject : inject mode --inject-ret : inject-ret mode --inject-post : inject-post mode --inject-post-ret : inject-post-ret mode --inject-full : inject-full mode Notes: --inject : call pre_func, jump to function-hooked --inject-ret : jump directly to pre_func and return its return value --inject-post : call function-hooked, post_func, then return function-hooked's return values --inject-post-ret : call function-hooked, post_func and return ist return value --inject-full : call pre_func, function-hooked, post_func, then return function-hooked's return value gef\u27a4 hook-got-inline --data --create Insert gdbleed script (Insert 'EOF' line to terminate reading input) int x = 10; char * pino = \"Hello pino\\n\"; blob data1 = 128; EOF gef\u27a4 hook-got-inline --data --list Id declaration 0 int x = 10; 1 char * pino = 0x25001f; // size=0xd 2 void * data1 = 0x25002b; // size=0x80 Create internal functions gef\u27a4 hook-got-inline --create ./example/bleed_example/internal_func.c.bleed /tmp/gdbleed/inspect_status.print_pino.c: In function \u2018print_pino\u2019: [...] Code compiled or maybe not, you should check that and change stuff (folder '/tmp/gdbleed/inspect_status.print_pino.c.o'). Do you want to retry compilation? (y/Y/-) /tmp/gdbleed/inspect_status.call_print_pino.c: In function \u2018call_print_pino\u2019: [...] Code compiled or maybe not, you should check that and change stuff (folder '/tmp/gdbleed/inspect_status.call_print_pino.c.o'). Do you want to retry compilation? (y/Y/-) gef\u27a4 hook-got-inline --list Id namespace full_name addr 0x0 inspect_status inspect_status.call_print_pino 0x20018e 0x1 inspect_status inspect_status.print_pino 0x2000ed print inspect_status.call_print_pino's details gef\u27a4 hook-got-inline --list inspect_status.call_print_pino Id namespace full_name addr 0x0 inspect_status inspect_status.call_print_pino 0x20018e \\---> description: Inspect arguments given to the hooking functions 'pre_func' and 'post_func' \\---> declaration: int call_print_pino(int j){ \\---> used_by_function: [] \\---> hooking_function: {'inspect_status.print_pino'} gef\u27a4 hook-got-inline --source-code inspect_status.call_print_pino 'inspect_status.call_print_pino' source code: // here we insert includes and struct typedf etc. // - we can have only one \"define\" sub-section #include <sys/types.h> #include <unistd.h> int call_print_pino(int j){ void * (*getpid)() = 0x7ffff7e640f0; void * (*printf)(void *, ...) = 0x7ffff7de1cc0; int * (*print_pino) (int i) = 0x2000ed; char * p = 0x2500ab; // size=0x17 char * p2 = 0x2500c1; // size=0xa char * pino = 0x25001f; // size=0xd // ## code starts from here: return print_pino(j); } Create pre_func which does call static variables and internal functions declared before gef\u27a4 hook-got-inline --create ./example/bleed_example/inspect_status[x86_64].c.bleed gef\u27a4 hook-got-inline --list Id namespace full_name addr 0x0 inspect_status inspect_status.call_print_pino 0x20018e 0x1 inspect_status inspect_status.print_pino 0x2000ed 0x2 inspect_status inspect_status.pre_func None gef\u27a4 hook-got-inline --source-code inspect_status.pre_func 'inspect_status.pre_func' source code: void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __arg5__, void * __arg6__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__){ void * (*printf)(void *, ...) = 0x7ffff7de1cc0; int * (*call_print_pino) (int j) = 0x20018e; char * p = 0x2500ca; // size=0xc1 char * pino = 0x25001f; // size=0xd int i = 0x1337; // ## code starts from here: printf(p, __fname__, __arg1__, __arg2__, __arg3__, __arg4__, __arg5__, __arg6__, __fname_length__, __fname__, __fname_addr__, __ret_addr__, __num_arg__, __sp_arg__); printf(pino); call_print_pino(i); return 1111; return 0; } Compile it and then hook 'fork' calls gef\u27a4 hook-got-inline --compile inspect_status.pre_func /tmp/gdbleed/inspect_status.pre_func.c: In function \u2018pre_func\u2019: [...] Code compiled or maybe not, you should check that and change stuff (folder '/tmp/gdbleed/inspect_status.pre_func.c.o'). Do you want to retry compilation? (y/Y/-) gef\u27a4 hook-got-inline --inject inspect_status.pre_func fork [TraceHook] Can't find symbol on '.dynstr', is imported by ordinale number.. searching it on LIBC memory space [TraceHook] Can't find symbol 'fork' on libc, inserting it by hand at addr '0x25018a' gef\u27a4 continue Result: Trace each external call passing from plt.got section gef\u27a4 hook-got-inline --inject --trace-all inspect_status.pre_func","title":"Start"},{"location":"start/#start-guide","text":"video Delete old gdbleed session which is saved into folder /tmp/gdbleed rm -rf /tmp/gdbleed Attach gdb to gdbserver session # e.g. we have /bin/bash with pid 258475, then we launch gdbserver as follows gdbserver --attach 127.0.0.1:12345 258475 # on gdb session cd <gdbleed-folder> gdb /bin/bash -ex \"source ~/.gdbinit-gef.py\" -ex \"target remote 127.0.0.1:12345\" -ex \"source gdbleed.py\" Because gdbleed does not know if the debuggee program is running in local or in remote it will ask you to choose on which path the binary is present. In any case if we are using gdbserver the 2nd options should be choosed. This information is later saved in gdbleed session (folder /tmp/gdbleed ) Inspect got entries gef\u27a4 got-entries ... [0x563275d6ced8] ---> socket [0x563275d6cee0] ---> mktemp gef\u27a4 got-entries fork [0x563275d6ce90] ---> fork Create static variables gef\u27a4 hook-got-inline --help Help Usage: hook-got-inline [options] <function_name> Options: --help : This message --create : insert gdbleed script from STDIN or by file <file_path> --data : Define or list global/static vars --list : print declared functions nformation --source-code : print function's source code --remove : delete function <function_name> --compile : Compile function --inject : inject mode --inject-ret : inject-ret mode --inject-post : inject-post mode --inject-post-ret : inject-post-ret mode --inject-full : inject-full mode Notes: --inject : call pre_func, jump to function-hooked --inject-ret : jump directly to pre_func and return its return value --inject-post : call function-hooked, post_func, then return function-hooked's return values --inject-post-ret : call function-hooked, post_func and return ist return value --inject-full : call pre_func, function-hooked, post_func, then return function-hooked's return value gef\u27a4 hook-got-inline --data --create Insert gdbleed script (Insert 'EOF' line to terminate reading input) int x = 10; char * pino = \"Hello pino\\n\"; blob data1 = 128; EOF gef\u27a4 hook-got-inline --data --list Id declaration 0 int x = 10; 1 char * pino = 0x25001f; // size=0xd 2 void * data1 = 0x25002b; // size=0x80 Create internal functions gef\u27a4 hook-got-inline --create ./example/bleed_example/internal_func.c.bleed /tmp/gdbleed/inspect_status.print_pino.c: In function \u2018print_pino\u2019: [...] Code compiled or maybe not, you should check that and change stuff (folder '/tmp/gdbleed/inspect_status.print_pino.c.o'). Do you want to retry compilation? (y/Y/-) /tmp/gdbleed/inspect_status.call_print_pino.c: In function \u2018call_print_pino\u2019: [...] Code compiled or maybe not, you should check that and change stuff (folder '/tmp/gdbleed/inspect_status.call_print_pino.c.o'). Do you want to retry compilation? (y/Y/-) gef\u27a4 hook-got-inline --list Id namespace full_name addr 0x0 inspect_status inspect_status.call_print_pino 0x20018e 0x1 inspect_status inspect_status.print_pino 0x2000ed print inspect_status.call_print_pino's details gef\u27a4 hook-got-inline --list inspect_status.call_print_pino Id namespace full_name addr 0x0 inspect_status inspect_status.call_print_pino 0x20018e \\---> description: Inspect arguments given to the hooking functions 'pre_func' and 'post_func' \\---> declaration: int call_print_pino(int j){ \\---> used_by_function: [] \\---> hooking_function: {'inspect_status.print_pino'} gef\u27a4 hook-got-inline --source-code inspect_status.call_print_pino 'inspect_status.call_print_pino' source code: // here we insert includes and struct typedf etc. // - we can have only one \"define\" sub-section #include <sys/types.h> #include <unistd.h> int call_print_pino(int j){ void * (*getpid)() = 0x7ffff7e640f0; void * (*printf)(void *, ...) = 0x7ffff7de1cc0; int * (*print_pino) (int i) = 0x2000ed; char * p = 0x2500ab; // size=0x17 char * p2 = 0x2500c1; // size=0xa char * pino = 0x25001f; // size=0xd // ## code starts from here: return print_pino(j); } Create pre_func which does call static variables and internal functions declared before gef\u27a4 hook-got-inline --create ./example/bleed_example/inspect_status[x86_64].c.bleed gef\u27a4 hook-got-inline --list Id namespace full_name addr 0x0 inspect_status inspect_status.call_print_pino 0x20018e 0x1 inspect_status inspect_status.print_pino 0x2000ed 0x2 inspect_status inspect_status.pre_func None gef\u27a4 hook-got-inline --source-code inspect_status.pre_func 'inspect_status.pre_func' source code: void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __arg5__, void * __arg6__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__){ void * (*printf)(void *, ...) = 0x7ffff7de1cc0; int * (*call_print_pino) (int j) = 0x20018e; char * p = 0x2500ca; // size=0xc1 char * pino = 0x25001f; // size=0xd int i = 0x1337; // ## code starts from here: printf(p, __fname__, __arg1__, __arg2__, __arg3__, __arg4__, __arg5__, __arg6__, __fname_length__, __fname__, __fname_addr__, __ret_addr__, __num_arg__, __sp_arg__); printf(pino); call_print_pino(i); return 1111; return 0; } Compile it and then hook 'fork' calls gef\u27a4 hook-got-inline --compile inspect_status.pre_func /tmp/gdbleed/inspect_status.pre_func.c: In function \u2018pre_func\u2019: [...] Code compiled or maybe not, you should check that and change stuff (folder '/tmp/gdbleed/inspect_status.pre_func.c.o'). Do you want to retry compilation? (y/Y/-) gef\u27a4 hook-got-inline --inject inspect_status.pre_func fork [TraceHook] Can't find symbol on '.dynstr', is imported by ordinale number.. searching it on LIBC memory space [TraceHook] Can't find symbol 'fork' on libc, inserting it by hand at addr '0x25018a' gef\u27a4 continue Result: Trace each external call passing from plt.got section gef\u27a4 hook-got-inline --inject --trace-all inspect_status.pre_func","title":"start guide"},{"location":"commands/readme/","text":"Commands list Runtime information gathering commands got-entries [symbol] : print all GOT entries or only the [symbol] entry base-address : print process base address binary-name : file path of the process binary-name-local : local file path of the binary Hook GOT entries using breakpoints trace-bp --symbol fork : trace fork calls and print function args using breakpoints trace-bp --trace-all : trace @plt calls and print function args using breakpoints trace-bp --reset : remove breakpoints that was setted with trace-bp Hook/instrument GOT entries using trampoline points hook-got : old method used for doing GOT hooking, the command will be deprecated soon for now just use it for clearing GOT entries as hook-got --reset-all hook-got-inline : read other docs Memory management hook-memory_mng : manage shadow memory dump-all : dump process memory and save it to <tmp_folder>/dump_dir folder mem-map : allocate memory using mmap, then malloc if mmap call failed mem-unmap : unallocate memory Save session (#TODO) store-state : use serialization for saving current gdbleed session to <tmp_folder>/state.bin load-state : load previous gdbleed session saved","title":"Commands"},{"location":"commands/readme/#commands-list","text":"","title":"Commands list"},{"location":"commands/readme/#runtime-information-gathering-commands","text":"got-entries [symbol] : print all GOT entries or only the [symbol] entry base-address : print process base address binary-name : file path of the process binary-name-local : local file path of the binary","title":"Runtime information gathering commands"},{"location":"commands/readme/#hook-got-entries-using-breakpoints","text":"trace-bp --symbol fork : trace fork calls and print function args using breakpoints trace-bp --trace-all : trace @plt calls and print function args using breakpoints trace-bp --reset : remove breakpoints that was setted with trace-bp","title":"Hook GOT entries using breakpoints"},{"location":"commands/readme/#hookinstrument-got-entries-using-trampoline-points","text":"hook-got : old method used for doing GOT hooking, the command will be deprecated soon for now just use it for clearing GOT entries as hook-got --reset-all hook-got-inline : read other docs","title":"Hook/instrument GOT entries using trampoline points"},{"location":"commands/readme/#memory-management","text":"hook-memory_mng : manage shadow memory dump-all : dump process memory and save it to <tmp_folder>/dump_dir folder mem-map : allocate memory using mmap, then malloc if mmap call failed mem-unmap : unallocate memory","title":"Memory management"},{"location":"commands/readme/#save-session-todo","text":"store-state : use serialization for saving current gdbleed session to <tmp_folder>/state.bin load-state : load previous gdbleed session saved","title":"Save session (#TODO)"},{"location":"settings/readme/","text":"Settings './config.py' tmp_folder : temporary folder used by gdbleed to save the current session log_file : file where gdbleed currently save session (for now binary and libc location) ARCH_supported : ARCH_supported compiler_path : Cross-Compiler paths compiler_flags : Cross-Compiler flags slog_path : save output to 'slog_path' file (default: stdout) './gdbleed.py' details : Dictionary passed through gdbleed classes containing data about the CPU architectures currently used \"capsize\" : Size of pointers \"word\" : format string for printable pointers in gdb using 'x' command notation \"arch\" : arch currently used \"isa\" : isa currently used \"running\" : process is running \"slog\" : slog class object \"endian\" : endianess \"is_pie\" : True if binary is PIE \"binary_path\" : binary path \"libc_path\" : libc path \"pid\" : PID \"session_loaded\" : True if session was loaded (TODO) \"qemu_usermode\" : True if qemu user-mode is used details_mem : Memory status info \"mm_regions\" : Dict containing memory mapped by the process saved as MemoryRegion objects \"mm_addresses\" : List containing LSB addresses of the memory mapped by the process \"mm_regions_ctrl\" : Dict containing memory mapped by gdbleed commands saved as MemoryRegion objects \"mm_addresses_ctrl\" : List containing LSB addresses of the memory mapped by gdbleed details_data : Binary related info (GOT, sections, etc.) \"binary_name\" : binary file name \"binary_name_local\" : binary file name (the one saved in local) \"base_address\" : base address given by the loader to the binary \"size_base_address\" : size base address \"libc_base_address\" : libc base address \"libc_size_base_address\" : size libc base address \"got_entries\" : GOT entries saved as WrapPLTGOT objects \"section_entries\" : ELF sections saved as WrapSection objects \"parser\" : WrapParser singleton object \"compiler\" : Compiler singleton object","title":"Settings"},{"location":"settings/readme/#settings","text":"","title":"Settings"},{"location":"settings/readme/#configpy","text":"tmp_folder : temporary folder used by gdbleed to save the current session log_file : file where gdbleed currently save session (for now binary and libc location) ARCH_supported : ARCH_supported compiler_path : Cross-Compiler paths compiler_flags : Cross-Compiler flags slog_path : save output to 'slog_path' file (default: stdout)","title":"'./config.py'"},{"location":"settings/readme/#gdbleedpy","text":"details : Dictionary passed through gdbleed classes containing data about the CPU architectures currently used \"capsize\" : Size of pointers \"word\" : format string for printable pointers in gdb using 'x' command notation \"arch\" : arch currently used \"isa\" : isa currently used \"running\" : process is running \"slog\" : slog class object \"endian\" : endianess \"is_pie\" : True if binary is PIE \"binary_path\" : binary path \"libc_path\" : libc path \"pid\" : PID \"session_loaded\" : True if session was loaded (TODO) \"qemu_usermode\" : True if qemu user-mode is used details_mem : Memory status info \"mm_regions\" : Dict containing memory mapped by the process saved as MemoryRegion objects \"mm_addresses\" : List containing LSB addresses of the memory mapped by the process \"mm_regions_ctrl\" : Dict containing memory mapped by gdbleed commands saved as MemoryRegion objects \"mm_addresses_ctrl\" : List containing LSB addresses of the memory mapped by gdbleed details_data : Binary related info (GOT, sections, etc.) \"binary_name\" : binary file name \"binary_name_local\" : binary file name (the one saved in local) \"base_address\" : base address given by the loader to the binary \"size_base_address\" : size base address \"libc_base_address\" : libc base address \"libc_size_base_address\" : size libc base address \"got_entries\" : GOT entries saved as WrapPLTGOT objects \"section_entries\" : ELF sections saved as WrapSection objects \"parser\" : WrapParser singleton object \"compiler\" : Compiler singleton object","title":"'./gdbleed.py'"},{"location":"strategy/pre_func/","text":"Pre_func The trampoline point pre_func is a set of assembly instructions which does expect the \".stack\" shadow memory to contain","title":"pre_func"},{"location":"strategy/pre_func/#pre_func","text":"The trampoline point pre_func is a set of assembly instructions which does expect the \".stack\" shadow memory to contain","title":"Pre_func"},{"location":"strategy/strategy/","text":"Strategy The following doc illustrates the logic behind hook-got-inline set of commands. Which for now does only hooking and basic instrumentation, but in future it will be true binary instrumentation stuff. Terms function-hooked : function to be hooked function-hooking : new generated code hooking/instrumenting the function-hooked shadow memory : new memory region added from gdbleed General ideas We map three new region of memory called shadow memory text : where new generated assembly code and trampoline points are saved data : data stack : here we save transitory data (no pthread support) To hook/instrument functions we have only 2 type of function: pre_func : observe a function-hooked before executing it post_func : observe a function-hooked after executing it pre_func is declared as: # for intel x64 void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __arg5__, void * __arg6__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); # for the other archs void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); post_func is declared as: # for intel x64 void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __arg5__, void * __arg6__, void * __rets__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); # for the other archs void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __rets__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); Based on these two functions, gdbleed builds 5 fixed types of trampoline points: ONLY_PRE_FUNC : Call pre_func, then jump to function-hooked RET_PRE_FUNC : Don't call function-hooked, call pre_func and return its return value ONLY_POST_FUNC : Call function-hooked, post_func, then return function-hooked's return value RET_POST_FUNC : Call function-hooked, then return post_func return value ALL_FUNC : Call pre_func, function-hooked, post_func and then return function-hooked's return value Before calling a trampoline point, the user needs to create its pre_func function, then gdbleed will create an injection point. The injection point is assembly code which will save function-hooked's arguments and stuff into stack shadow-memory, then will call the right trampoline point. Injection points are univoke for each function-hooked. Instead, trampoline points are saved in fixed memory areas. The trampoline point will prepare the stack before calling the custom pre_func/function-hooked/post_func function. The trampoline points approaches ONLY_PRE_FUNC trampoline control flow: : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: prepare new stack frame and arguments \\ \\---> 3: CALL `pre_func` code / <---/ 2: trampoline_point_<i> (2) | 2.3: restore registers and old stack frame \\ \\---> 4: JMP to `<function>` / : caller <---/ RET_PRE_FUNC control flow: : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: prepare new stack frame and arguments \\ \\---> 3: CALL `pre_func` code / <---/ 2: trampoline_point_<i> (2) | 2.3: restore registers and old stack frame | 2.4: set `pre_func`'s return value \\ \\---> 4: jump to return address / : caller <---/ ONLY_POST_FUNC control flow : : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: set return address as trampoline_point_<i>(2) \\ \\---> 3: jump <function> / <---/ 2: trampoline_point_<i> (2) | 2.3: save <function>'s return value | 2.4: prepare new stack frame and arguments \\ \\---> 4: CALL `post_func` code / <---/ 2: trampoline_point_<i> (3) | 2.5: restore registers and old stack frame | 2.6: set <function>'s return value \\ \\---> 5: jump to return address / : caller <---/ RET_POST_FUNC control flow : : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: set return address as trampoline_point_<i>(2) \\ \\---> 3: jump <function> / <---/ 2: trampoline_point_<i> (2) | 2.3: save <function>'s return value | 2.4: prepare new stack frame and arguments \\ \\---> 4: CALL `post_func` code / <---/ 2: trampoline_point_<i> (3) | 2.5: restore registers and old stack frame | 2.6: set `post_func`'s return value \\ \\---> 5: jump to return address / : caller <---/ ALL_FUNC control flow: Do ONLY_PRE_FUNC and ONLY_POST_FUNC both .c.bleed \"scripting\" An user can inject pre_func and post_func functions as .bleed scripts, by invoking the command : gef> hook-got-inline --create <path-to-example.c.bleed> We can't declare variables that will be put on data-type ELF sections, so instead we should keep pre_func and post_func functions as simple as possible. Gdbleed supports a limited type of variable types. To overcome this limitation, before declaring pre_func and post_func, we declare internal functions. We don't link the source code but just compile it in object code. If we need to call a library function we need to declare it in @@external-functions@@ sections, then gdbleed will resolve the address and save it into source code before making it into object file. For more information read the following doc: Declaring static data Declaring internal functions Declaring pre_func Steps during a .c.bleed file parsing Parse sections, a section does start with -- Parse --declare-- section first. Here we declare variables and functions (externals and locals) @@types@@ : define types (TODO, for now declare them using internal functions) @@vars@@ : key-value mapping, for now supporting numerical types, void * and char * also @@external-functions@@ : external functions (libc, but not limited to that) which our script depends on Parse --code-- section. Here we write down the local functions and the functions pre_func and post_func. Because of some constraints only one type of function would be compiled. @@functions@@ : static functions @@pre_func@@ : code executed before calling the hooked function @@post_func@@ : code executed after the hooked function returns (#TODO) pre_func notes function declaration: void * pre_func( void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, #ifdef IS_x86_64 void * __arg5__, void * __arg6__, #endif unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__ ); argument of the hooked function meaning: __arg1__ : 1st arg __arg2__ : 2nd arg __arg3__ : 3rd arg __arg4__ : 4th arg __arg5__ : 5th arg (only available for x86_64 arch) __arg6__ : 6th arg (only available for x86_64 arch) __fname_length__ : name length of the function-hooked __fname__ : address of the function-hooked name __fname_addr__ : address of the function-hooked function __ret_addr__ : original return address __num_arg__ : the number of arguments given to the hooked function (TODO) __sp_arg__ : stack pointer where the other arguments of the hooked function were saved __rets__ : return value after calling the hooked function (only available in post_func function)","title":"Strategy"},{"location":"strategy/strategy/#strategy","text":"The following doc illustrates the logic behind hook-got-inline set of commands. Which for now does only hooking and basic instrumentation, but in future it will be true binary instrumentation stuff.","title":"Strategy"},{"location":"strategy/strategy/#terms","text":"function-hooked : function to be hooked function-hooking : new generated code hooking/instrumenting the function-hooked shadow memory : new memory region added from gdbleed","title":"Terms"},{"location":"strategy/strategy/#general-ideas","text":"We map three new region of memory called shadow memory text : where new generated assembly code and trampoline points are saved data : data stack : here we save transitory data (no pthread support) To hook/instrument functions we have only 2 type of function: pre_func : observe a function-hooked before executing it post_func : observe a function-hooked after executing it pre_func is declared as: # for intel x64 void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __arg5__, void * __arg6__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); # for the other archs void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); post_func is declared as: # for intel x64 void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __arg5__, void * __arg6__, void * __rets__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); # for the other archs void * pre_func(void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, void * __rets__, unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__); Based on these two functions, gdbleed builds 5 fixed types of trampoline points: ONLY_PRE_FUNC : Call pre_func, then jump to function-hooked RET_PRE_FUNC : Don't call function-hooked, call pre_func and return its return value ONLY_POST_FUNC : Call function-hooked, post_func, then return function-hooked's return value RET_POST_FUNC : Call function-hooked, then return post_func return value ALL_FUNC : Call pre_func, function-hooked, post_func and then return function-hooked's return value Before calling a trampoline point, the user needs to create its pre_func function, then gdbleed will create an injection point. The injection point is assembly code which will save function-hooked's arguments and stuff into stack shadow-memory, then will call the right trampoline point. Injection points are univoke for each function-hooked. Instead, trampoline points are saved in fixed memory areas. The trampoline point will prepare the stack before calling the custom pre_func/function-hooked/post_func function.","title":"General ideas"},{"location":"strategy/strategy/#the-trampoline-points-approaches","text":"ONLY_PRE_FUNC trampoline control flow: : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: prepare new stack frame and arguments \\ \\---> 3: CALL `pre_func` code / <---/ 2: trampoline_point_<i> (2) | 2.3: restore registers and old stack frame \\ \\---> 4: JMP to `<function>` / : caller <---/ RET_PRE_FUNC control flow: : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: prepare new stack frame and arguments \\ \\---> 3: CALL `pre_func` code / <---/ 2: trampoline_point_<i> (2) | 2.3: restore registers and old stack frame | 2.4: set `pre_func`'s return value \\ \\---> 4: jump to return address / : caller <---/ ONLY_POST_FUNC control flow : : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: set return address as trampoline_point_<i>(2) \\ \\---> 3: jump <function> / <---/ 2: trampoline_point_<i> (2) | 2.3: save <function>'s return value | 2.4: prepare new stack frame and arguments \\ \\---> 4: CALL `post_func` code / <---/ 2: trampoline_point_<i> (3) | 2.5: restore registers and old stack frame | 2.6: set <function>'s return value \\ \\---> 5: jump to return address / : caller <---/ RET_POST_FUNC control flow : : caller 0:'<function>'@GOT \\---> 1: Injection-point | 1.1: Prepare stack shadow memory \\ \\---> 2: trampoline_point_<i> with i in [1..5] | 2.1: save registers | 2.2: set return address as trampoline_point_<i>(2) \\ \\---> 3: jump <function> / <---/ 2: trampoline_point_<i> (2) | 2.3: save <function>'s return value | 2.4: prepare new stack frame and arguments \\ \\---> 4: CALL `post_func` code / <---/ 2: trampoline_point_<i> (3) | 2.5: restore registers and old stack frame | 2.6: set `post_func`'s return value \\ \\---> 5: jump to return address / : caller <---/ ALL_FUNC control flow: Do ONLY_PRE_FUNC and ONLY_POST_FUNC both","title":"The trampoline points approaches"},{"location":"strategy/strategy/#cbleed-scripting","text":"An user can inject pre_func and post_func functions as .bleed scripts, by invoking the command : gef> hook-got-inline --create <path-to-example.c.bleed> We can't declare variables that will be put on data-type ELF sections, so instead we should keep pre_func and post_func functions as simple as possible. Gdbleed supports a limited type of variable types. To overcome this limitation, before declaring pre_func and post_func, we declare internal functions. We don't link the source code but just compile it in object code. If we need to call a library function we need to declare it in @@external-functions@@ sections, then gdbleed will resolve the address and save it into source code before making it into object file. For more information read the following doc: Declaring static data Declaring internal functions Declaring pre_func Steps during a .c.bleed file parsing Parse sections, a section does start with -- Parse --declare-- section first. Here we declare variables and functions (externals and locals) @@types@@ : define types (TODO, for now declare them using internal functions) @@vars@@ : key-value mapping, for now supporting numerical types, void * and char * also @@external-functions@@ : external functions (libc, but not limited to that) which our script depends on Parse --code-- section. Here we write down the local functions and the functions pre_func and post_func. Because of some constraints only one type of function would be compiled. @@functions@@ : static functions @@pre_func@@ : code executed before calling the hooked function @@post_func@@ : code executed after the hooked function returns (#TODO) pre_func notes function declaration: void * pre_func( void * __arg1__, void * __arg2__, void * __arg3__, void * __arg4__, #ifdef IS_x86_64 void * __arg5__, void * __arg6__, #endif unsigned long __fname_length__, char * __fname__, void * __fname_addr__, void * __ret_addr__, unsigned long __num_arg__, void * __sp_arg__ ); argument of the hooked function meaning: __arg1__ : 1st arg __arg2__ : 2nd arg __arg3__ : 3rd arg __arg4__ : 4th arg __arg5__ : 5th arg (only available for x86_64 arch) __arg6__ : 6th arg (only available for x86_64 arch) __fname_length__ : name length of the function-hooked __fname__ : address of the function-hooked name __fname_addr__ : address of the function-hooked function __ret_addr__ : original return address __num_arg__ : the number of arguments given to the hooked function (TODO) __sp_arg__ : stack pointer where the other arguments of the hooked function were saved __rets__ : return value after calling the hooked function (only available in post_func function)","title":".c.bleed \"scripting\""}]}